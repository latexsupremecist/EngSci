# print
cat("Hello World!") # no semicolon at the end
cat(a)
# print
cat("Hello World!") # no semicolon at the end
engsci_adj <- -12
x <- 97 + engsci_adj
engsci_adj <- -12
# Hi, I'm a comment
# print with cat
cat("Hello World!") # no semicolon at the end
# Variables
# We use <- (ALT - ) for assign, instead of =
engsci_adj <- -12
x <- 97 + engsci_adj
# These are displayed in the Environment
# To run a line, use CTRL ENTER
a <- 1
b <- 2
c <- 3
no_roots <- b**2 - 4*a*c < 0
cat(no_roots)
exam_grade <- 94
# C-like syntax
if(exam_grade >= 95){
cat("Yay")
}else if(exam_grade >= 94){
cat("OK")
}else{
cat("Drop out")
}
installed.packages("rmarkdown")
install.packages("gapminder")
installed.packages("gapminder")
library(gapminder)
Sys.info()
packageVersion(gapminder)
packageVersion("gapminder")
installed.packages(gapminder)
installed.packages("gapminder")
detach("package:gapminder", unload = TRUE)
library(gapminder)
library(rmarkdown)
installed.packages("gapminder")
installed.packages("asdf")
installed.packages(gapminder)
installed.packages("rmarkdown")
installed.packages("rmarkdown")
str(ip <- installed.packages(.Library, priority = "high"))
ip[, c(1,3:5)]
plic <- installed.packages(.Library, priority = "high", fields = "License")
## what licenses are there:
table( plic[, "License"] )
# }
installed.packages("gapminder", fileds = "Version")
a = installed.packages("gapminder")
a
table(a)
table(a[,"Version"])
installed.packages("cli")
.libPaths()
a <- installed.packages("gapminder")
View(a)
a
dim(a)
a <- installed.packages()
packages<-a[,1]
is.element("gapminder",packages)
ls
c("hello world")
v[1]
v <- cat(TRUE, FALSE, TRUE, TRUE)
v[1]
v[2]
v[3]
v[4]
v <- c(TRUE, FALSE, TRUE, TRUE)
v[1]
v[2]
v[3]
v[4]
v <- c(2, -50, 2, 4)
sorted_v <- sort(v)
length(v)
v <- c(2, -1, 2, 2, 5, 1)
unique(v)
v <- c(2, -50, 2, 4)
sort(v)
length(v)
max(v)
min(v)
v <- c(2, -1, 2, 2, 5, 1)
unique(v)
TRUE | FALSE
FALSE | FALSE
TRUE | TRUE
v <- c(5, 2, -1, 1)
v[v>0]
v <- c(5, 2, -1, 1)
v[v>0]
v[v>=0 & v<= 3]
v <- c(5, 2, -1, 1)
v[v>0]
v[v>=0 & v<= 3]
cat(v, 3)
v <- c(5, 2, -1, 1)
v[v>0]
v>=0 & v<= 3
v[v>=0 & v<= 3]
cat(v, 3)
offer <- c(241, 590, 533, 425, 261)
offer > 400 # gives vector of booleans
offer[offer > 400] # gives vector of offers greater than 400
# To understand how it works, consider how
# offer > 400 == [FALSE, TRUE, TRUE, TRUE, FALSE]
# offer[FALSE, TRUE, TRUE, TRUE, FALSE] = [offer[2], offer[3], offer[4]]
offer[FALSE, TRUE, TRUE, TRUE, FALSE]
offer[FALSE TRUE TRUE TRUE FALSE]
offer(FALSE, TRUE, TRUE, TRUE, FALSE)
offer(1)
c(offer(1))
cat(offer)
cat(offer[1])
cat(offer[FALSE, TRUE, TRUE, TRUE, FALSE])
dim(offer)
size(offer)
offer[cat(FALSE, TRUE, TRUE, TRUE, FALSE)]
offer[c(FALSE, TRUE, TRUE, TRUE, FALSE)]
offer[offer > 400 & offer < 550]
offer[!(offer > 400 & offer < 550)]
offer[offer <= 400 | offer >= 550]
# Essentially De Morgan's Law
offer[400 > offer]
max(offer)
spec <- c("family doc", "cardiologist", "ortho", "dermatologist", "psychiatrist")
# We want to know the specialty that earns the most
spec[offer == max(offer)]
# max(offer) gives the maximum value
# offer == max(offer) is in the form vector == number, which gives a vector of booleans with at least one TRUE
# spec == vector of booleans gives the location of max offer(s)
(1:length(spec))[offer == max(offer)]
elems_below <- function(vec, upper_bound){
vec[vec <= upper_bound]
}
elems_below(c(5, 1, 2, 3), 2)
my_median <- function(vec){
vec <- sort(vec)
len <- length(vec)
if(len%%2 == 1){
vec((len+1)/2)
}else{
(vec(len/2) + vec((len/2) + 1))/2
}
}
my_median(c(5, 1, 2, 10, 1, 2, 7))
my_median <- function(vec){
vec <- sort(vec)
len <- length(vec)
if(len%%2 == 1){
vec[(len+1)/2]
}else{
(vec[len/2] + vec[(len/2) + 1])/2
}
}
my_median(c(5, 1, 2, 10, 1, 2, 7))
my_median <- function(vec){
vec <- sort(vec)
len <- length(vec)
if(len%%2 == 1){
vec[(len+1)/2]
}else{
(vec[len/2] + vec[(len/2) + 1])/2
}
}
my_median(c(5, 1, 2, 10, 1, 2, 7))
my_median(c(1, 1, 2, 3))
my_median <- function(vec){
vec <- sort(vec)
len <- length(vec)
if(len%%2 == 1){
vec[(len+1)/2]
}else{
(vec[len/2] + vec[(len/2) + 1])/2
}
}
my_median(c(5, 1, 2, 10, 1, 2, 7))
offers <- data.frame(amount = c(241, 590, 533),
spec = c("family", "cardio", "ortho"))
view(offers)
offers <- data.frame(amount = c(241, 590, 533),
spec = c("family", "cardio", "ortho"))
view(offers)
View(offers)
install.packages("babynames")
View(babynames)
View("babynames")
library(babynames)
View(babynames)
babynames[2, ]
library(babynames)
# View(babynames) # file too large, don't actually load it
View(babynames[2, ]) # View the second row
View(babynames[2:6, c("name", "year")])
# Views the second to sixth row, filtered only for name and year
# View(babynames$prop) # gets entire column, again file very large
# $ gives a vector
babynames$prop[1]
# babynames[, "prop"] gives  a dataframe. Since babynames is a datafram, babynames[, "prop"] returns a data frame with one column. Hence we need
babynames[, "prop"][1, "prop"]
babynames$prop[1]
babynames[, "prop"][1, "prop"]
year = 1999
babies_year <- babynames[babynames$year == year, ]
# you can use View(babies.year) to see it
# babynames$ year == year is a vector of booleans
max_name_count <- max(babies_year$n)
(babies_year$name)[max_name_count == babies_year$n]
# returns vector of most popular names
View(babies_year)
babies_year_f <- babies_year[babies_year$sex == "F"]
babies_year_f <- babynames[babynames$sex == "F" & babynames$year == year]
babies_year_f <- babies_year[babyname$sex == "F", ]
babies_year_f <- babies_year[babies_year$sex == "F", ]
# Then do the same
max_name_count <- max(babies_year_f$n)
(babies_year_f$name)[max_name_count == babies_year_f$n]
View(installed.packages)
installed.packages("dypler")
install.packages("dypler")
install.package("tidyverse")
install.packages("tidyverse")
f <- function(x){
x^2
}
g <- function(y){
y + 2
}
# To compose both functions, we can do
f(g(5))
# but also
library(tidyverse)
5 %>% g %>% f
# or
5 %>% g() %>% f()
View(gapminder)
library(gapminder)
View(gapminder)
